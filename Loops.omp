; OM File Header - Saved 2020/07/08 17:43:28
; (6.16 :patc (om-make-point 604 10) (om-make-point -8 -8) (om-make-point 1280 637) "" 183 0 "2020/06/29 14:29:26" "2020/07/08 17:43:09")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "Loops" (quote ((let ((box (om-load-boxcall (quote abstraction) "lispfunction 2" (om-load-lisp-abspatch "lispfunction 2" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction 2\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (cond ((null x) nil)$((oddp (first x)) t)$(t (anyoddp (cdr x)))))") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 684 396) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 313 380) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 243 387) (om-make-point 26 28) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM<" (quote om<) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 275 431) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 498 235) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 475 155) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 180 349) (om-make-point 39 28) " b" "\" b\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 46 353) (om-make-point 25 28) "a" "\"a\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x y) $  (concatenate 'string x y))") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "Y" nil))) (om-make-point 90 406) nil (list "a b") nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 428 407) (om-make-point 33 28) 15 "15" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 334 437) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((15))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 331 66) (om-make-point 147 28) (list "foo" "bar" "Hello World!") "(\"foo\" \"bar\" \"Hello World!\")" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 226 67) (om-make-point 75 28) (list 1.1 2.2 3.3) "(1.1 2.2 3.3)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 144 69) (om-make-point 53 28) (list (quote a) (quote b) (quote c) (quote d)) "(a b c d)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 399 54) (quote "Looping World ") "" (om-make-point 510 15) nil (om-make-color 1.0 0.0 0.0) (om-make-font "Verdana" 30 :family "Verdana" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoopOn2" (om-load-lisp-abspatch "forLoopOn2" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (loop :for (i j) :on x$        :do (print (list i j)))$)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 937 215) nil (list nil) nil "forLoopOn2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoopOn" (om-load-lisp-abspatch "forLoopOn" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (loop :for i :on x$        :collect i)$)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 1025 226) nil (list (list (list (quote a) (quote b) (quote c) (quote d)) (list (quote b) (quote c) (quote d)) (list (quote c) (quote d)) (list (quote d)))) nil "forLoopOn"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "stepping the list:$cdr $cddr$cddr") "" (om-make-point 1038 353) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoopBy" (om-load-lisp-abspatch "forLoopBy" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (loop for i in x by #'cdr$        do (print i)$        sum i)$)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 947 351) nil (list nil) nil "forLoopBy"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "multiClause2" (om-load-lisp-abspatch "multiClause2" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for x :below 10$        :collect $        (loop :for y :below 10$              :collect (+ x y)))$)") (quote nil) (om-make-point 999 123) nil (list (list (list 0 1 2 3 4 5 6 7 8 9) (list 1 2 3 4 5 6 7 8 9 10) (list 2 3 4 5 6 7 8 9 10 11) (list 3 4 5 6 7 8 9 10 11 12) (list 4 5 6 7 8 9 10 11 12 13) (list 5 6 7 8 9 10 11 12 13 14) (list 6 7 8 9 10 11 12 13 14 15) (list 7 8 9 10 11 12 13 14 15 16) (list 8 9 10 11 12 13 14 15 16 17) (list 9 10 11 12 13 14 15 16 17 18))) nil "multiClause2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "multiClause" (om-load-lisp-abspatch "multiClause" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for x :below 10$        :for y :below 10$        :collect (+ x y))$)") (quote nil) (om-make-point 930 123) nil (list (list 0 2 4 6 8 10 12 14 16 18)) nil "multiClause"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop7" (om-load-lisp-abspatch "forLoop7" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (loop :for i :in x$        :collect (+ i i))$)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 586 289) nil (list (list 0 2 4 6)) nil "forLoop7"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop6" (om-load-lisp-abspatch "forLoop6" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for i :below 10$        :do (print i)$        :when (= i 8)$        :return 'Foo)$)") (quote nil) (om-make-point 764 217) nil (list (quote foo)) nil "forLoop6"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop5" (om-load-lisp-abspatch "forLoop5" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for i :below 10$        :when (oddp i)$        :sum i)$        $)") (quote nil) (om-make-point 679 212) nil (list 25) nil "forLoop5"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop4" (om-load-lisp-abspatch "forLoop4" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for i :below 5$        do (print i))$)") (quote nil) (om-make-point 587 208) nil (list nil) nil "forLoop4"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop3" (om-load-lisp-abspatch "forLoop3" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) $  (loop :for i :in x$        sum i)$)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 761 140) nil (list 6) nil "forLoop3"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop2" (om-load-lisp-abspatch "forLoop2" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for i :from 5 :to 10$        :do (print i)$        :sum i)$)") (quote nil) (om-make-point 688 131) nil (list 45) nil "forLoop2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "forLoop1" (om-load-lisp-abspatch "forLoop1" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () $  (loop :for i :below 5$        :do (print i)$        :sum i)$)") (quote nil) (om-make-point 594 129) nil (list 10) nil "forLoop1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "omloopwhile" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 141 197) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 292 216) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 50 117) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 175 128) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM<" (quote om<) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 90 227) (om-make-point 94 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "while" (quote whileloop) (quote ((om-load-inputfun (quote input-funbox) "condition" "EXPR" nil))) (om-make-point 52 299) nil nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 363 314) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 208 314) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (5 0 1 0 nil 0) (1 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (0 1 6 0 nil 0) (0 0 7 0 nil 0))) 1 "omloopwhile" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP 4" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 383 207) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "sum" (quote sum) (quote ((om-load-inputfun (quote input-funbox) "numbers to sum" "NUMBER" nil))) (om-make-point 316 117) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINT" (quote print) (quote ((om-load-inputfun (quote input-funbox) "SOMETHING" "SOMETHING" nil))) (om-make-point 229 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 35 161) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 355 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "omloop 4" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "omloop 3" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 308 205) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "PRINT" (quote print) (quote ((om-load-inputfun (quote input-funbox) "SOMETHING" "SOMETHING" nil))) (om-make-point 228 211) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 296 132) (om-make-point 52 58) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 439 296) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 284) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "omloop 3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 232 200) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 244 132) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "onlist" (quote onlistloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 39 93) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 309 267) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 166 267) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 2 0 nil 0) (0 1 3 0 nil 0) (0 0 4 0 nil 0))) 1 "omloop 2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 59 75) (om-make-point 55 28) (list 0 1 2 3) "(0 1 2 3)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 3 0 nil 0) (1 0 3 1 nil 0) (11 0 4 0 nil 0) (11 0 5 0 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (9 0 10 6 nil 0) (13 0 25 0 nil 0) (32 0 28 0 nil 0) (32 0 29 0 nil 0))) nil 6.16))
